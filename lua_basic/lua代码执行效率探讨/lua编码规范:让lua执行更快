--
--1.使用luajit 替换lua51, 可以让lua 代码执行得更快
--





--
--2.避免触发'解析器'进行解析(提高30%解析效率):
--
如在for 循环体:
	-- 必然性触发解析进行解析, 一次解析, 永久使用
	-- (可以出现同名, local本地优先, 会直接覆盖, 为了方便阅读, 不产生歧义, 使用同名最好)
	local math = require("math")
	local sin = math.sin

	-- 解析后使用
	for i=1, 100000 do
		sin(i)
	end

	-- 一边运行一边解析(错误)
	for i=1, 100000 do
		math.sin(i)
	end

其它应用场景同理, lua 编码类似于c/c++, 
c/c++ 需要在函数头部, 初始化所有local 临时变量,
lua 需要在函数头部, 初始化所有需要解析的东西, 以避免解析器陷入循环中.





--
--3.lua table 数据结构
--
lua table 实际上, 就是一个hash table, 
优点是:
	访问速度快, 媲美数组
缺点是:
	增/删操作速度十分慢, 比红黑树还要慢多了,
	所以, 尽量减少'增/删lua table'的操作.



'增/删操作'的缺陷:
	当lua 向table中插入一个新键, 而table哈希数组已满的时候, lua会重新哈希一次table.
	重新哈希第一步是:
		决定'新数组部分'和'新哈希部分'的大小.
	因此, lua遍历table所有元素, 并对其计数,分类,
	然后选择table数组的最大尺寸(n^2)长度, 重建成新的table, 再把元素填回去.
	由此可见, 性能损耗十分大.

例如:
	-- 避免触发解析器
	local t={}
	-- t{}表会不断'重新哈希', 性能损耗十分大!!(尽量不要这样写lua代码, 换一种思维去表述)
	for i=1, 1000000 do
		t[i] = i
	end



lua table 中一旦出现nil 元素, 就会触发重新哈希, 重新排序:
例如:
	local t={0,0,0,0}
	t[1]=nil




旧版本lua创建空表时, 会预分配4个位置, 以避免这种初始化小表时的开销:
	-- 等价
	local t={}
	local t={0,0,0,0}



'gc 回收table'的缺陷:
	由于lua table 是哈希表的缘故, 因此lua table 扩展后, 是不会自动缩减的.
	例如一个lua table:
		以前装进去32 个元素, 
		后面元素减少到16 个元素,
		但lua table 还是32 个元素的大小, 空间大小不变.

	因此, lua table可以重用的情况下, 就需要重用.
	-- 只需定义一个临时变量tmp_tab 即可, 尽量重复使用!!
	local tmp_tab={}

	最后用完之后, 命令gc 回收lua table:
		tmp_tab=nil



关于lua table 迭代器遍历:
	--迭代器的效率可以, 但是仍然不如[1] 下标快
	for i=1, 100000 do								--迭代访问效率最好
		tmp_tab[i] = tmp_tab[i]+1
	end
	for k in pairs(tmp_tab) do				--迭代访问效率中等
		k=k+1
	end
	for i=next(tmp_tab), 100000 do		--迭代访问效率最差
		i=i+1
	end





--
--4.lua 字符串
--
第一, lua中所有的字符串都是内化的. 意思是:
	lua对任一字符串只保留一份拷贝. 
	无论何时出现新字符串, lua会检测这个字符串是否已经存在备份, 如果是, 重用拷贝(节约内存).
	内化使像字符串的比较和表索引操作非常快, 
	但也正因如此, lua 创建一个新的字符串, 会比较慢.

第二, lua中的变量从不持有字符串, 仅是引用他们(所以字符串读取速度很快).
	也正因为如此, 使用lua 字符串的时候, 应该避免触发频繁创建字符串, 频繁修改字符串.





--
--5.使用折线(...), 减少*.lua 的代码量, 也减少lua 即装载内存(装载文本量少了), 也减少解析器压力
--
polyline = { x = { 10.3, 10.3, 15.0, ...},
        　　　y = { 98.5, 18.3, 98.5, ...}
}

local t = {1, 2, 3, "hi"}
function foo (...)
　　for i = 1, n do
　　　　-- do something without changing ’t’
　　　　...
　　end
end



